## 搭建并行处理管道，感受 Go 语言的魅力

**初识 Go 语言的并行计算**

慕课网视频：[搭建并行处理管道，感受 Go 语言的魅力](https://www.imooc.com/learn/927)
* Google 资深工程师讲解，个人感觉非常经典
* PPT 文字脱敏⬇️

大部分 Go 语言的重心都放在语法的特点与小细节上面

学习新语言的特点后，找一个不那么简单的项目去做
* 边做边看文档
* 边做边查 StackOverflow

### Go 语言的项目
**完全使用 Go 语言**
* Docker
* Kubernetes
* Caddy
* CockroachDB

**部分使用Go语言**
* MongoDB/Couchbase
* Dropbox
* Uber
* Google

### Go 语言的发展趋势
* [https://octoverse.github.com/](https://octoverse.github.com/)
* [https://www.indeed.com/jobtrends/q-golang.html](https://www.indeed.com/jobtrends/q-golang.html)

### Go 语言在中国
* [https://trends.google.com/trends/explore?q=%2Fm%2F09gbxjr](https://trends.google.com/trends/explore?q=%2Fm%2F09gbxjr)

### Google 内部的 “标准” 编程语言
* C++：必须有性能保障的部分，如搜索引擎
* Java：复杂业务逻辑，如 adwords, google docs
* Python：大量内部工具
* Go：新的内部工具，及其他业务模块，如dl.google.com

### Go语言的设计初衷
* 如果有一门语言，有像C/C++那样的性能，可以做系统开发
* 但是没有繁琐的类型系统，有简单统一化的模块依赖管理，编译速度飞快
* 如果有一门语言，像Java那样拥有垃圾回收
* 但是更快，对业务的影响更小
* 如果有一门语言，像 Python 那样简单易学，拥有灵活的类型，支持函数式编程，异步IO
* 但是有编译器进行静态类型检查
* 如果有一门语言，针对上述痛点进行设计，并加入并发编程
* 这就是 Go 语言

### Go 语言的归类
* 类型检查：编译时
* 运行环境：编译成机器代码直接运行
* 编程范式：面向接口，函数式编程，并发编程

### Go 语言并发编程
* 采用CSP(Communication Sequential Process)模型
* 不需要锁，不需要callback
* 并发编程 VS 并行计算
* Go语言一个并发编程的模型，涵盖面非常的广，包括两大类
  * 并行计算
    * 有一个很明确的计算任务
    * 把计算任务分到各个节点去做
    * 做完以后就去合并一下，得到最终的结果
  * 分布式
    * 比较复杂，没有一个具体的流程
    * 有很多人互相等来等去，互相的传递消息
* 这节课
  * 关注并行计算的管道
    * 并发编程领域中一个简单的任务
    * 并行计算Pipeline，最简单的任务是**外部排序**
      * 数据量很多，内存放不下
      * 很多台机器并行的去排，排好了然后归并起来

### Hello World
* 普通 Hello World
* Hello World Server - 读取 url 中的参数
* 并发 Hello World - 初识 goroutine 与 channel
* 一个简单的排序
  * 直接调用库函数 -->> sort.Ints(args) 

### 外部排序
**归并排序回顾**
* 将数据分为左右两半，分别归并排序（就是一个递归），再把两个有序数据合并
  * 递归调用完以后，我们就认为左右两半都排完了
  * 把它们合并就可以了
  * 如果我们能做到这一点，我们不断的递归下去，就能把整个数组排出来
* 如何归并
  * [1,3,6,7],[1,2,3,5] -> 1
    * 看看谁小，一样小，取左边的 1
  * [3,6,7],[1,2,3,5] -> 1
    * 看看谁小，取右边的 1
  * [3,7,7],[2,3,5] -> 2
    * 看看谁小，取右边的 2
  * [3,7,7],[3,5] -> 3
  * ...
  * 这是内部排序中的归并排序，非常的简单
* 归并排序的好处
  * 很容易扩展到左右两半的数据非常非常大的情况
  * 归并排序的每一步，它不需要看整个数组，只需要看每个数组的头就可以了
    * 用掉以后，再看后面一个
    * 这样就不需要把两个很大的数组同时放在内存里，我们可以一个一个读

**外部排序会把很大的一个数据源进行切分**
* 算一算切成多少份
* 每一份在一个节点里面
* 在这个节点里面它有足够的内存进行排序
* 内部排序很简单，调用下 `sort.Ints` 就好了
* 两个两个节点的归并，节点一多会反复的读取外部的数据源，会造成性能上的浪费
* 使用 K 路归并，3 个节点甚至 10 个节点一起归并
* 需要同时存储 K 个节点的最小元素，这个存储结构叫做一个堆的存储结构
* 如何用堆进行 K 路归并？算法性比较强一点
* 本节课，两路归并

### 一些节点
* 数组数据源节点 - channel的关闭及检测
* 内部排序的节点
* 归并的节点

### 更多节点
* ReaderSource节点
* WriterSink节点
* 测试数据生成

### 单机版外部排序 pipeline
* ReadSource节点-支持分块
* MergeN - 搭建归并节点
* pipeline 的搭建及运行 - CPU 及线程数量的观测

### 集群版外部排序

### go 语言三大特色
* 面向接口-Reader/Writer 接口的使用
* 函数式编程
* 并发编程

### 进一步学习
```sh
go tool tour
```