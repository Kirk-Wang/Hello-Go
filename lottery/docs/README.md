# 抽奖系统的实现

### demo 运行

VSCode + Code Runer 扩展
```sh
Run Code
Stop Code Run
```

### 抽奖系统的业务难点
 
* 抽奖的业务需求，既复杂有多变
* 奖品类型和概率设置
* 如何保证公平的抽奖，安全的发奖？

### 抽奖系统的技术挑战

* 网络并发编程，数据读写的并发安全性问题
* 高效的抽奖和发奖，提高并发和性能
* 系统优化，怎么把 redis 更好的利用起来

### Go vs PHP/JAVA

* 高并发，Go 协程优于 PHP 多进程，JAVA 多线程模式
* 高性能，编译后的二进制优于PHP解释型，JAVA 虚拟机
* 高效网络模型，epoll 优于 PHP BIO，JAVA 的 NIO

### 6 种抽奖活动

* 年会抽奖
* 彩票刮奖
* 微信摇一摇
* 支付宝集福卡
* 微博墙抢红包
* 抽奖大转盘

### 系统设计

* 需求/流程
* 数据库/架构

### 项目实战

* 框架/核心代码 
* 后台功能
* mysql版本
* 优化-使用redis
* 发奖计划与奖品池

### 演示和总结

* 合理设置奖品
* 合理发放奖品
* 压力测试
* 更多运营策略

### 引入 thrift 框架

* 设计接口
* 生成代码
* 服务端接口
* 客户端程序

### 6 种抽奖活动来一遍

#### 年会抽奖程序-annualMeeting

* 需求：导入全公司员工名单，`每次随机抽取出来一个人`
* 未知：有一等奖，二等奖，也有领导`临时`增加的产品
* 年会抽奖不涉及并发，但抽奖程序还是要考虑并发安全性问题

编写web单元测试和并发安全问题

* import "sync"
  - wg := sync.WaitGroup{}
    - wg.Add(1)
    - wg.Done()
    - wg.Wait()
  
用互斥锁解决并发安全问题

* import "sync"
- var mu sync.Mutex 
- mu = sync.Mutex{}

在 `/import` & `/lucky` 加上 `mu.Lock()` & `defer mu.Unlock()`

所有的并发都会在同一个共享变量读写的地方进行排队，而不是各自进行读写

#### 彩票刮奖-ticket

* 即开即得型，挂挂乐，随机尾号数字
* 定时开奖型，双色球，随机7位数字
* 稳赚，技术难度谁做谁谁知道
  - 可以通过数学准确的计算出抽奖概率的，只要参与的人数足够多

两个功能
1. 即开即得型
2. 双色球自选型

#### 微信摇一摇-wechatShake

* 人、歌曲、电视、`奖品`，种类多，数量多
* 随机匹配奖品，针对虚拟币、虚拟券、实物等，不一样的发奖规则
* 中奖后，减库存，记录并且提示用户。考虑`线程安全性问题`

`/lucky` 只有一个抽奖接口

定义枚举：奖品类型，枚举值 iota 从 0 开始

压力测试

```sh
wrk -t10 -c10 -d5 http://localhost:8080/lucky
# -t: 线程数
# -c: 连接数
# -d: 持续时间

wc -l lottery_demo.log # 查看文件有多少行

echo "" > lottery_demo.log # 清空下数据
```

检测性能和并发安全问题(超卖问题！！！)--> 简单解决-》sync.Mutex

#### 支付宝集福卡-alipayFu

* 奖品是虚拟的5个福字，没有数量限制
* 先识别图片，确定福字的获得概率
* 不存在线程安全问题
* 概率来自于图片扫描，动态的设置

```sh
wrk -t10 -c10 -d5 http://localhost:8080/lucky?uid=1&rate=4,3,2,1,0
wc -l lottery_demo.log
echo "" > lottery_demo.log
```

#### 微博抢红包-weiboRebPacket

* 多个用户发出来多个红包，更多用户来抢红包
* 红包的集合，红包内红包数量的读写都存在并发安全性问题
* 优化，将红包集合进行散列，减小单个集合的大小

```sh
#设置红包
http://localhost:8080/set?uid=1&money=100&num=100
#抢红包
http://localhost:8080/get?uid=1&id=1
#并发压力测试
wrk -t10 -c10 -d5 http://localhost:8080/set?uid=1&money=100&num=100

wrk -t10 -c10 -d5 http://localhost:8080/get?uid=1&id=918254297
```
均衡问题
* 调整下 rMax

sync.Map 

* 线程安全
* 性能会有些许问题
    * 但大量并发的读，写很少的话，也不会特别的明显

chan 方式解决并发安全问题

#### 抽奖大转盘-wheel

* 抽奖前，用户已知全部奖品信息
* 后端设置各个奖品的`中奖概率和数量限制`
* 更新奖品库存的时候存在并发安全性问题
    * sync.Mutex
    * atomic.AddInt32()

```sh
wc -l lottery_demo.log
echo "" > lottery_demo.log
# total=100000 left=100000
# 压测5秒钟
wrk -t10 -c10 -d5 http://localhost:8080/prize
# 看一下 `left` + `request` =? `total`
```

#### 抽奖活动总结
* 关键点，奖品类型，数量有限，中奖概率，发奖规则
* 并发安全性问题，互斥锁，队列，CAS递减
* 优化，通过散列减少单个集合的大小

### 需求整理和提炼

前端页面的需求

* 交互效果，大转盘的展示
* 用户登录，每天抽奖次数限制
* 获奖提示和中奖列表

后端接口的需求

* 1 奖品列表，2 抽奖，3 中奖列表
* 抽奖接口需要满足`高性能和高并发`要求
* 安全抽奖，奖品`不能超发`，合理均匀发放

后台管理的需求

* 基本的数据管理：奖品，优惠券，用户，IP黑名单，中奖纪录
* 实时更新奖品信息，更新奖品库存，奖品中奖周期等
* 后台定时任务，生成发奖计划，填充奖品池

### 用户操作和业务流程

用户操作步骤：

* 登录
* 抽奖页面
    * 奖品列表
    * 中奖纪录和剩余抽奖次数
* 抽奖
    * 参数验证
    * 中奖
* 发奖
    * 中奖纪录
    * 中奖提示

奖品状态变化

* 正常奖品
    * 奖品有效期
    * 奖品的库存
* 奖品池

抽奖业务流程
* 抽奖
* 验证登录
* 用户抽奖锁定 (防重入)
* 验证用户今日参与次数
* 验证IP今日最大限制次数
* 验证IP今日抽奖次数
    * IP 超过了今日抽奖次数，但没有到最大限制
    * 可以继续抽奖，只不过不能得到实物大奖
* 验证IP黑名单
    * 有，不能获取实物大奖
* 验证用户黑名单
    * 有，不能获取实物大奖
* 获得抽奖编码（随机）
* 匹配奖品
* 验证奖品池库存
* 发奖更新奖品库存
* (发放优惠券，还有一个特殊的流程)
* 中奖纪录
* 返回结果

### 数据库设计

* 奖品
* 优惠券
* 中奖纪录
* 用户黑名单
    - 刷接口的
    - 不能中大奖
* IP 黑名单
    - 刷接口的
    - 不能中大奖
* 用户今日参与次数

### 缓存设计

如何设计和利用缓存

* 目标，提高系统`性能`，减少数据库依赖
* 原则，`平衡`好"系统性能，开发时间，复杂度"
* 方向，数据`读多写少`，数据量`有限`，数据`分散`

使用 redis 缓存的地方

* `奖品`，数量少，更新频率低，最佳的`全量缓存`对象
* `优惠券`，一次性导入，优惠券编码缓存为`set类型`
* `中奖纪录`，读写差不多，可以`缓存部分统计数据`，如：最新中奖纪录，最近大奖发放纪录等
* `用户黑名单`，读多写少，可以按照 `uid散列`
* `IP黑名单`，类似用户黑名单，可以按照 `ip散列`
* 用户每日参与次数，读写次数差异没有用户黑名单那么明显，缓存后的`收益不明显`

### 系统架构设计

架构设计的前提知识

    - 架构师很厉害、很高深？
    - 架构设计基本都类似
    - 架构是方案，不只是一个结果，而要有很多的对比权衡

网络架构图

系统架构图

总结

* 需求充分考虑运营需要，用户操作尽量简单
* 数据库设计，定义数据模型，简单够用，留下扩展空间
* 架构设计，分层架构设计，网络：负载均衡层/应用层/存储层;
    - 应用：业务代码/框架代码/存储服务

### 项目框架的搭建

创建项目目录

* 公共的目录，如：bootstrap,comm,conf,dao等
* web 目录，如：controllers,public, views等
* 系统主程序 main.go 文件

### 数据模型的生成

xorm-cmd 工具的使用

[详细使用方式](https://github.com/go-xorm/cmd)

```sh
go get github.com/go-xorm/cmd/xorm
```

* 数据库连接
```sh
root:123456@tcp(127.0.0.1:3306)/lottery?charset=utf8
```
* mysql，我当前本机
```sh
xorm reverse mysql root:123456@tcp(127.0.0.1:3306)/lottery?charset=utf8 $GOPATH/pkg/mod/github.com/go-xorm/cmd/xorm@v0.0.0-20190426080617-f87981e709a1/templates/goxorm
```

### 核心的 dao 和 services 类

dao 面向数据库，services 面向数据服务
* dao的基础方法，Get, GetAll, CountAll, Search, Delete, Update, Create

* services的基础方法，Get, GetAll, CountAll, Search, Delete, Update, Create

* 特殊方法，如：根据 ip 查找 GetById, 根据用户和日期查找 Search(uid, day int) 等

### 利用 iris 建立 web 站点

* bootsrapper 启动项，comm 公用方法
    * 注意单例的构建与 `sync.Mutex`
* web/controllers控制器业务逻辑
* web/public静态资源文件

### 用户登录和退出

基于 Cookie 的用户状态

* ObjLoginuser 登录用户对象
* 登录用户对象与Cookie的读写
* Cookie的安全校验值，不能被篡改

### 后台功能开发

奖品管理

* views: 奖品列表页，奖品信息编辑页
* 数据保存，删除，恢复功能
* admin_gift 业务逻辑控制器

优惠券管理

* views: 优惠券列表页
* 导入优惠券，删除、恢复功能
* admin_code 业务逻辑控制器

中奖纪录管理

* views:中奖纪录列表页
* 删除，恢复，设置作弊功能
* admin_result业务逻辑控制器

用户管理

* views:用户列表页
* 洗白，黑一周等功能
* admin_user 业务逻辑控制器

IP 黑名单管理

* views:IP黑名单列表页
* 洗白，黑一周等功能
* admin_blackip 业务逻辑控制器

### 基于 mysql 的抽奖功能开发

#### 抽奖接口开发

抽奖的业务逻辑

* 验证，登录，今日参与次数，黑名单信息
* 抽奖，匹配奖品
* 发奖，奖品有剩余，纪录中奖，返回结果

步骤（可以用插件的方式做）：

1. 验证登录用户
2. 用户抽奖分布式锁定（只锁某一个用户请求，对其它用户请求没有影响）
3. 验证用户今日参与次数
4. 验证 IP 今日的参与次数
5. 验证 IP 黑名单
6. 验证用户黑名单
7. 获得抽奖编码
8. 匹配奖品是否中奖
9. 有限制奖品发放
10. 不用编码的优惠券的发放
11. 纪录中奖纪录
12. 返回抽奖结果

#### 用户并发操作的🔐锁(利用redis)

防止同一个用户的重入 `LockLucky` & `UnlockLucky`

1. 不安全：`并发` 验证，并发数据更新
2. 分布式锁：保证 `原子性` ,避免死锁
    - Do("SET", key, 1, "EX", 3, "NX")
        * `NX` 不存在才能 `SET`，解决冲突问题
    - 例：三秒后自动释放，避免死锁
    - 加锁成功，立即 `defer Unlock`
    - 加锁失败-->重入-->直接返回 `正在抽奖`
3. 用户请求结束，必须及时 `释放锁`

#### 验证用户/IP今日参与次数

同一个用户/IP的每日参与次数

- 强制限制同一个用户/IP，不能超出今日参与次数
- 每日参与次数的数据更新，原子性递增
- IP的今日参与次数需要用 redis 缓存来实现
    * 同一个 IP 的客户端可能比较多（公司，学校） 
        * 将 IP 转换为整数后，进行散列处理，然后生成 key
        * Do("HINCRBY", key, ip, 1)
         ```json
            {
                "day_ips_0": {
                    "ip1": 1,
                    "ip3": 1
                }
            }
            {
                "day_ips_1": {
                    "ip2": 2,
                    "ip4": 2
                }
            }
         ```
         * 注意(启动程序/凌晨)时要注意 Reset (计划任务)

#### IP 黑名单，用户黑名单的处理

黑名单不能获取实物奖

* 安全机制，避免同一个 IP 大量用户的刷奖
* 公平机制，`中过大奖` 的用户在一段时期内把机会让出来
* 验证方法，数据存在并且在黑名单限制时间内

#### 抽奖的实现

随机匹配奖品

- 随机得到一个`抽奖编码`
- 根据抽奖编码，匹配有效的奖品中奖`编码区间`
- 奖品是有序的，后台可以设置`顺序`,避免编码区间的包含关系

#### 发奖的实现

奖品有剩余才可以发出去

* 数据库实现 `原子性` 奖品库存数量的递减
* 不同优惠券的发放，需要用到 `分布式锁`
* 找到 `下一个` 可用的优惠券 `codeService.NextUsingCode`

#### 中奖纪录和返回结果

中奖纪录和返回结果中需要包含奖品信息

- 奖品信息可能修改，但是中奖纪录中不能改
- 如果用户中了实物大奖，还需要把用户、IP设置为`黑名单`一段时间
- 返回结果的数据结构需要保持一致

### 优化-使用 redis 缓存

奖品数据全量缓存，JSON 序列化为 string 结构，gift_service

- 增加 3 个方法，getAllByCache,setAllByCache,updateByCache
- 修改读取方法，增加 useCache bool 参数
- 修改数据的时候，清空缓存，下次读取的时候自动更新最新数据

单个用户数据的缓存，hash 结构，user_service

- 增加3个方法，getByCache,setByCache,updateByCache
- 修改Get,Update方法，增加对缓存方法的调用
- 修改数据的时候，清空缓存，下次读取的时候自动更新最新数据

IP 黑名单数据的缓存，hash 结构，blackip_service

- 增加3个方法，getByCache,setByCache,updateByCache
- 修改 GetById, Update 方法，增加对缓存方法的调用
- 修改数据的时候，清空缓存，下次读取的时候自动更新最新数据

IP 今日抽奖次数，hash 中的计数器，utils/ip_day_lucky

- IncrlpLuckyNum 原子性递增 IP 今日的抽奖次数
- resetGroupIpList 每天凌晨计数器归零
- ipFrameSize 优化，将 hash 结构散列为多段数据，让每个 has 小点

用户今日抽奖次数，hash 中的计数器，utils/user_day_lucky

- IncrUserLuckyNum 原子性递增用户今日的抽奖次数
    * InitUserLuckyNum 从数据库初始化缓存数据
- resetGroupUserList 每天凌晨计数器归零
- userFrameSize 优化，将 hash 结构散列为多段数据，让每个 hash 小点



