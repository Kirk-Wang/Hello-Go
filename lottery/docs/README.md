# 抽奖系统的实现

### demo 运行

VSCode + Code Runer 扩展
```sh
Run Code
Stop Code Run
```

### 抽奖系统的业务难点
 
* 抽奖的业务需求，既复杂有多变
* 奖品类型和概率设置
* 如何保证公平的抽奖，安全的发奖？

### 抽奖系统的技术挑战

* 网络并发编程，数据读写的并发安全性问题
* 高效的抽奖和发奖，提高并发和性能
* 系统优化，怎么把 redis 更好的利用起来

### Go vs PHP/JAVA

* 高并发，Go 协程优于 PHP 多进程，JAVA 多线程模式
* 高性能，编译后的二进制优于PHP解释型，JAVA 虚拟机
* 高效网络模型，epoll 优于 PHP BIO，JAVA 的 NIO

### 6 种抽奖活动

* 年会抽奖
* 彩票刮奖
* 微信摇一摇
* 支付宝集福卡
* 微博墙抢红包
* 抽奖大转盘

### 系统设计

* 需求/流程
* 数据库/架构

### 项目实战

* 框架/核心代码 
* 后台功能
* mysql版本
* 优化-使用redis
* 发奖计划与奖品池

### 演示和总结

* 合理设置奖品
* 合理发放奖品
* 压力测试
* 更多运营策略

### 引入 thrift 框架

* 设计接口
* 生成代码
* 服务端接口
* 客户端程序

### 6 种抽奖活动来一遍

#### 年会抽奖程序-annualMeeting

* 需求：导入全公司员工名单，`每次随机抽取出来一个人`
* 未知：有一等奖，二等奖，也有领导`临时`增加的产品
* 年会抽奖不涉及并发，但抽奖程序还是要考虑并发安全性问题

编写web单元测试和并发安全问题

* import "sync"
  - wg := sync.WaitGroup{}
    - wg.Add(1)
    - wg.Done()
    - wg.Wait()
  
用互斥锁解决并发安全问题

* import "sync"
- var mu sync.Mutex 
- mu = sync.Mutex{}

在 `/import` & `/lucky` 加上 `mu.Lock()` & `defer mu.Unlock()`

所有的并发都会在同一个共享变量读写的地方进行排队，而不是各自进行读写

#### 彩票刮奖-ticket

* 即开即得型，挂挂乐，随机尾号数字
* 定时开奖型，双色球，随机7位数字
* 稳赚，技术难度谁做谁谁知道
  - 可以通过数学准确的计算出抽奖概率的，只要参与的人数足够多

两个功能
1. 即开即得型
2. 双色球自选型

#### 微信摇一摇-wechatShake

* 人、歌曲、电视、`奖品`，种类多，数量多
* 随机匹配奖品，针对虚拟币、虚拟券、实物等，不一样的发奖规则
* 中奖后，减库存，记录并且提示用户。考虑`线程安全性问题`

`/lucky` 只有一个抽奖接口

定义枚举：奖品类型，枚举值 iota 从 0 开始

压力测试

```sh
wrk -t10 -c10 -d5 http://localhost:8080/lucky
# -t: 线程数
# -c: 连接数
# -d: 持续时间

wc -l lottery_demo.log # 查看文件有多少行

echo "" > lottery_demo.log # 清空下数据
```

检测性能和并发安全问题(超卖问题！！！)--> 简单解决-》sync.Mutex

#### 支付宝集福卡-alipayFu

* 奖品是虚拟的5个福字，没有数量限制
* 先识别图片，确定福字的获得概率
* 不存在线程安全问题
* 概率来自于图片扫描，动态的设置

```sh
wrk -t10 -c10 -d5 http://localhost:8080/lucky?uid=1&rate=4,3,2,1,0
wc -l lottery_demo.log
echo "" > lottery_demo.log
```

#### 微博抢红包-weiboRebPacket

* 多个用户发出来多个红包，更多用户来抢红包
* 红包的集合，红包内红包数量的读写都存在并发安全性问题
* 优化，将红包集合进行散列，减小单个集合的大小

```sh
#设置红包
http://localhost:8080/set?uid=1&money=100&num=100
#抢红包
http://localhost:8080/get?uid=1&id=1
#并发压力测试
wrk -t10 -c10 -d5 http://localhost:8080/set?uid=1&money=100&num=100

wrk -t10 -c10 -d5 http://localhost:8080/get?uid=1&id=918254297
```
均衡问题
* 调整下 rMax

sync.Map 

* 线程安全
* 性能会有些许问题
    * 但大量并发的读，写很少的话，也不会特别的明显

chan 方式解决并发安全问题

#### 抽奖大转盘-wheel

* 抽奖前，用户已知全部奖品信息
* 后端设置各个奖品的`中奖概率和数量限制`
* 更新奖品库存的时候存在并发安全性问题
    * sync.Mutex
    * atomic.AddInt32()

```sh
wc -l lottery_demo.log
echo "" > lottery_demo.log
# total=100000 left=100000
# 压测5秒钟
wrk -t10 -c10 -d5 http://localhost:8080/prize
# 看一下 `left` + `request` =? `total`
```

#### 抽奖活动总结
* 关键点，奖品类型，数量有限，中奖概率，发奖规则
* 并发安全性问题，互斥锁，队列，CAS递减
* 优化，通过散列减少单个集合的大小

### 需求整理和提炼

前端页面的需求

* 交互效果，大转盘的展示
* 用户登录，每天抽奖次数限制
* 获奖提示和中奖列表

后端接口的需求

* 1 奖品列表，2 抽奖，3 中奖列表
* 抽奖接口需要满足`高性能和高并发`要求
* 安全抽奖，奖品`不能超发`，合理均匀发放

后台管理的需求

* 基本的数据管理：奖品，优惠券，用户，IP黑名单，中奖纪录
* 实时更新奖品信息，更新奖品库存，奖品中奖周期等
* 后台定时任务，生成发奖计划，填充奖品池

### 用户操作和业务流程

用户操作步骤：

* 登录
* 抽奖页面
    * 奖品列表
    * 中奖纪录和剩余抽奖次数
* 抽奖
    * 参数验证
    * 中奖
* 发奖
    * 中奖纪录
    * 中奖提示

奖品状态变化

* 正常奖品
    * 奖品有效期
    * 奖品的库存
* 奖品池

抽奖业务流程
* 抽奖
* 验证登录
* 用户抽奖锁定 (防重入)
* 验证用户今日参与次数
* 验证IP今日最大限制次数
* 验证IP今日抽奖次数
    * IP 超过了今日抽奖次数，但没有到最大限制
    * 可以继续抽奖，只不过不能得到实物大奖
* 验证IP黑名单
    * 有，不能获取实物大奖
* 验证用户黑名单
    * 有，不能获取实物大奖
* 获得抽奖编码（随机）
* 匹配奖品
* 验证奖品池库存
* 发奖更新奖品库存
* (发放优惠券，还有一个特殊的流程)
* 中奖纪录
* 返回结果

### 数据库设计

* 奖品
* 优惠券
* 中奖纪录
* 用户黑名单
    - 刷接口的
    - 不能中大奖
* IP 黑名单
    - 刷接口的
    - 不能中大奖
* 用户今日参与次数

### 缓存设计

如何设计和利用缓存

* 目标，提高系统`性能`，减少数据库依赖
* 原则，`平衡`好"系统性能，开发时间，复杂度"
* 方向，数据`读多写少`，数据量`有限`，数据`分散`



   


